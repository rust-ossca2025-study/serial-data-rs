# Week 1: Rust 기초 학습

## 1. Rust 언어의 특성

### Rust는 어떤 프로그래밍 패러다임인가?

Rust는 **다중 패러다임 프로그래밍 언어**입니다:

- **절차지향적 특성**: 함수 기반 프로그래밍, 명령형 스타일
- **객체지향적 특성**: 구조체(struct), 열거형(enum), 메서드
- **함수형 특성**: 클로저, 이터레이터, 패턴 매칭
- **시스템 프로그래밍**: 메모리 안전성, 제로 코스트 추상화

### Rust의 핵심 특징

1. **메모리 안전성**: 소유권(Ownership) 시스템으로 메모리 누수 방지
2. **동시성 안전성**: 데이터 레이스 방지
3. **제로 코스트 추상화**: 고수준 추상화가 런타임 오버헤드 없음
4. **타입 안전성**: 컴파일 타임에 타입 검사

## 2. 00_intro.rs - 함수 분리 연습

### 원본 코드 vs 개선된 코드

**원본 (단순한 구조):**
```rust
fn main() {
    // 모든 로직이 main 함수 안에 있음
    let customerid = Some(get_user_input());
    let productid = Some(get_user_input());
    let plain_serial = format!("{}{}", customerid.unwrap(), productid.unwrap());
    // ...
}
```

**개선된 구조 (함수 분리):**
```rust
fn get_user_input(prompt: &str) -> String { /* ... */ }
fn generate_serial(customer_id: &str, product_id: &str) -> String { /* ... */ }
fn extract_ids(serial: &str) -> (&str, &str) { /* ... */ }
fn validate_input(customer_id: &str, product_id: &str) -> bool { /* ... */ }

fn main() {
    // main 함수는 전체 흐름만 관리
    let customer_id = get_user_input("4자리 고객 ID를 입력하세요: ");
    let product_id = get_user_input("8자리 제품 ID를 입력하세요: ");
    // ...
}
```

### 함수 분리의 장점

1. **가독성 향상**: 각 함수가 하나의 명확한 역할
2. **재사용성**: 다른 곳에서도 함수를 재사용 가능
3. **테스트 용이성**: 각 함수를 독립적으로 테스트 가능
4. **유지보수성**: 코드 수정 시 영향 범위가 명확
5. **확장성**: 새로운 요구사항이 추가될 때 기존 코드에 영향 없이 확장 가능

### 개인적인 경험과 적용

평소 다른 언어에서도 최대한 모듈화를 많이 하려고 했었는데, 이번에도 같은 원칙을 적용해보았다. 특히 확장성에 대해서도 생각하면 예를 들어 `validate_input` 같은 경우에도 지금은 글자수로만 확인했는데, 다른 확인할 것들이 생겨난다면 분리하는 것이 좋을 것 같다.

### Rust의 특성상 더욱 중요한 모듈화

Rust의 특성상 모듈화가 더욱 중요하다:

- **소유권 시스템**: 함수 분리를 통해 소유권과 수명 주기를 명확히 관리
- **타입 안전성**: 각 함수의 입력/출력 타입을 명확히 정의하여 컴파일 타임에 오류 검출
- **제로 코스트 추상화**: 함수 분리가 런타임 성능에 영향을 주지 않음
- **크레이트 생태계**: 작은 단위의 함수들이 다른 프로젝트에서 재사용 가능
- **테스트 친화적**: Rust의 테스트 시스템과 잘 맞아떨어짐

### 학습한 Rust 개념들

- **함수 정의**: `fn` 키워드, 매개변수, 반환 타입
- **문자열 처리**: `String`, `&str`, `format!` 매크로
- **조건문**: `if`, `if let`
- **문서화**: `///` 주석으로 함수 문서화
- **모듈 시스템**: `use` 구문으로 외부 크레이트 사용

## 3. 01_encrypt.rs - 향후 개선 계획

### 현재 상태
- 기본적인 암호화 기능 구현
- `magic-crypt` 크레이트 사용
- 단위 테스트 추가

### 개선이 필요한 부분

1. **에러 처리 개선**
   - `unwrap()` 대신 `Result` 타입 사용
   - 적절한 에러 메시지 제공

2. **입력 유효성 검사**
   - 고객 ID 4자리, 제품 ID 8자리 검증
   - 잘못된 입력에 대한 처리

3. **코드 구조 개선**
   - 상수 분리
   - 함수 분리
   - 환경 변수 사용

4. **보안 강화**
   - 하드코딩된 키 제거
   - 환경 변수에서 키 가져오기

### 다음 주 학습 계획

- [ ] 에러 처리 패턴 학습
- [ ] `Result`와 `Option` 타입 깊이 있게 이해
- [ ] 테스트 코드 작성법 연습
- [ ] 크레이트 사용법 및 의존성 관리

## 4. 학습한 Rust 문법 요소들

### 기본 문법
- 변수 선언: `let`, `mut`
- 함수 정의: `fn`
- 문자열: `String`, `&str`
- 매크로: `println!`, `format!`

### 제어 흐름
- 조건문: `if`, `if let`
- 반복문: `for`, `while`
- 패턴 매칭: `match`

### 모듈과 크레이트
- `use` 구문
- 외부 크레이트 사용 (`magic-crypt`)
- `Cargo.toml` 의존성 관리

### 테스트
- `#[cfg(test)]` 속성
- `#[test]` 함수
- `assert!`, `assert_eq!`, `assert_ne!`

## 5. 다음 단계

1. **에러 처리 심화 학습**
2. **소유권(Ownership) 시스템 이해**
3. **트레이트(Trait) 시스템 학습**
4. **실제 프로젝트에 적용** 